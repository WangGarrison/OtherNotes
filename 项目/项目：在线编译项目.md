# README.md

在线编译项目：2021.02.04 - 2021.02.08

代码行数：1300

本项目是跟着王晨做的，实现了登录、注册、在线答题等功能，服务器在线判题返回结果等功能有待实现

本项目旨在对Linux学过的各种知识应用实践，加深理解，为后期自己做正式的简历项目打好基础

项目代码：

- 本地：F:\学习\项目\online_compile
- 腾讯微云：[online_compile](https://www.weiyun.com/disk/folder/9cbae39c7e4a317d59accaf52e1f2edb)

# 基础知识

> 该项目只是一个demo，必须在此基础上作修改、作扩充：在线小说阅读...在线视频播放...

- 网络知识：TCP编程	
- 并发编程：多进程、多线程，进程池、线程池，I/O复用
- 存储部分：MySQL
- 扩充：Redis服务器，服务器集群：负载均衡、反向代理

# 项目需求分析

**仿leetcode在线编译模块：**

1. 用户在本端编辑代码，然后服务器端进行编译链接、执行，返回一个结果
2. 用户管理模块
3. 在线答题系统：接口，用户选择后，随机在题库中抽取5道题，让用户来完成
4. 分析：根据用户的答题记录，给用户一些建议，即根据用户出错记录，推荐不同标签的题：C、C++、操作系统、网络
5. ……

**业务相关的功能模块划分：**

1. 用户信息管理模块：注册，登录，修改，注销，完善个人信息，实名认证等
2. 题库管理模块：增，删，改，查
3. 答题模块：在线编译
4. 评论管理模块
5. ……

> 软件开发流程：需求分析、概要设计、详细设计、编码、测试、软件交付、验收、维护

# 系统设计

框架搭建，接口，数据结构，调用关系

![image-20210405231333101](img/%E9%A1%B9%E7%9B%AE%EF%BC%9A%E5%9C%A8%E7%BA%BF%E7%BC%96%E8%AF%91%E9%A1%B9%E7%9B%AE.img/image-20210405231333101.png)

# 学到的

## extern

![image-20210405231344983](img/%E9%A1%B9%E7%9B%AE%EF%BC%9A%E5%9C%A8%E7%BA%BF%E7%BC%96%E8%AF%91%E9%A1%B9%E7%9B%AE.img/image-20210405231344983.png)

## epoll_wait

epoll_wait应用程序索引就绪文件描述符时间复杂度O(1)

![image-20210405231419001](img/%E9%A1%B9%E7%9B%AE%EF%BC%9A%E5%9C%A8%E7%BA%BF%E7%BC%96%E8%AF%91%E9%A1%B9%E7%9B%AE.img/image-20210405231419001.png)

## fgets

![image-20210405231437749](img/%E9%A1%B9%E7%9B%AE%EF%BC%9A%E5%9C%A8%E7%BA%BF%E7%BC%96%E8%AF%91%E9%A1%B9%E7%9B%AE.img/image-20210405231437749.png)

## 指针和变量结合

![image-20210405231446668](img/%E9%A1%B9%E7%9B%AE%EF%BC%9A%E5%9C%A8%E7%BA%BF%E7%BC%96%E8%AF%91%E9%A1%B9%E7%9B%AE.img/image-20210405231446668.png)

## sprintf

![image-20210405231458875](img/%E9%A1%B9%E7%9B%AE%EF%BC%9A%E5%9C%A8%E7%BA%BF%E7%BC%96%E8%AF%91%E9%A1%B9%E7%9B%AE.img/image-20210405231458875.png)

![image-20210405231507349](img/%E9%A1%B9%E7%9B%AE%EF%BC%9A%E5%9C%A8%E7%BA%BF%E7%BC%96%E8%AF%91%E9%A1%B9%E7%9B%AE.img/image-20210405231507349.png)

## case语句大括号

switch case语句中，如果case语句里面有定义变量，要加大括号

![image-20210405231521499](img/%E9%A1%B9%E7%9B%AE%EF%BC%9A%E5%9C%A8%E7%BA%BF%E7%BC%96%E8%AF%91%E9%A1%B9%E7%9B%AE.img/image-20210405231521499.png)

## warning：implicit... 

```shell
warning: implicit declaration of function
    警告：函数的隐式声明
```

 出现这种警告原因：缺少对应的头文件

![image-20210405231530577](img/%E9%A1%B9%E7%9B%AE%EF%BC%9A%E5%9C%A8%E7%BA%BF%E7%BC%96%E8%AF%91%E9%A1%B9%E7%9B%AE.img/image-20210405231530577.png)

## gdb调试

- 先在makefile里面gcc后加上-g选项，使生成的是debug版本
- 然后`gdb  server`，打开要调试的可执行文件
- 按`l`显示代码，按`b 行号`添加断点
- r开始运行到断点处
- n继续运行
- 按q退出
- 查看变量值：p valname

## mysql_real_connect返回NULL

![image-20210405231541419](img/%E9%A1%B9%E7%9B%AE%EF%BC%9A%E5%9C%A8%E7%BA%BF%E7%BC%96%E8%AF%91%E9%A1%B9%E7%9B%AE.img/image-20210405231541419.png)

用gdb调试LinkDataBase函数，发现是mysql_real_connect返回NULL了

![image-20210405231549338](img/%E9%A1%B9%E7%9B%AE%EF%BC%9A%E5%9C%A8%E7%BA%BF%E7%BC%96%E8%AF%91%E9%A1%B9%E7%9B%AE.img/image-20210405231549338.png)

**解决方案：**

先用fprintf输出一下具体错误

![image-20210405231600633](img/%E9%A1%B9%E7%9B%AE%EF%BC%9A%E5%9C%A8%E7%BA%BF%E7%BC%96%E8%AF%91%E9%A1%B9%E7%9B%AE.img/image-20210405231600633.png)

创建/var/run/mysqld这个文件夹，更改文件的权限，重启mysql

```shell
mkdir -p /var/run/mysqld
chown mysql.mysql /var/run/mysqld/

service mysqld restart
```

## find命令

```shell
find / -name mysql.cnf 
#从根目录开始查找名字为mysql.cnf的文件
```

![image-20210405231610552](img/%E9%A1%B9%E7%9B%AE%EF%BC%9A%E5%9C%A8%E7%BA%BF%E7%BC%96%E8%AF%91%E9%A1%B9%E7%9B%AE.img/image-20210405231610552.png)

## grep和 | 命令

```shell
find / *.conf | grep my.conf   
#从根目录开始查找名字后缀为.cnf的文件，然后从查找的结果中过滤出名字为my.conf的
```

![image-20210405231618789](img/%E9%A1%B9%E7%9B%AE%EF%BC%9A%E5%9C%A8%E7%BA%BF%E7%BC%96%E8%AF%91%E9%A1%B9%E7%9B%AE.img/image-20210405231618789.png)

## EPOLLONESHOT事件

即使使用ET模式,一个socket上的某个事件还是可能被触发多次.这在并发程序中会引发一个问题. 

比如一个线程在读取完某个socket上的数据后开始处理这些数据,而在数据的处理过程中,该socket上又有新数据可读(EPOLLIN再次被触发),此时另外一个线程被唤醒来读取这些新的数据.于是出现了两个线程同时操作一个socket的局面.我们期望的是一个socket连接在任何一个时刻只能被一个线程处理.

如果希望==一个socket连接的任一时刻都只被一个线程处理==，可以使用 EPOLLONESHOT 事件实现。

对于注册了EPOLLONESHOT事件的文件描述符,操作系统最多只触发其上注册的一个可读,可写,异常事件,且只触发一次.除非我们使用epoll_ctl函数重置该文件描述符上注册的EPOLLONESHOT事件.

注意：注册了EPOLLONESHOT事件的socket一旦被某个线程处理完毕，该线程就应该立即重置这个socket上的EPOLLONESHOT事件，以确保这个socket下一次可读时，其EPOLLIN事件能被触发，进而让其他工作线程有机会继续处理这个socket