## 进程的4G虚拟地址空间

进程有自己的独立地址空间，每启动一个进程，系统就会为它分配地址空间，虚拟地址空间的大小由计算机的硬件平台决定，比如32位的平台决定了虚拟地址空间为4G

在linux下内存分配是以页为单位的，而页是通过段管理

一个linux进程的虚拟地址空间分布如下图所示，分为用户空间和内核空间，对于一个32位操作系统来说，4GB的空间分成两部分，**低地址的0~3G**给用户空间，**高地址的3G~4G**给内核空间

![image-20201121233109085](img/Linux%EF%BC%9A%E8%BF%9B%E7%A8%8B%E7%9A%844G%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4.img/image-20201121233109085.png)

## 不可访问区

是用户不可访问的128M地址空间，上图给的是到0x40000000( x86-64Linux系统)，(32Linux)中是到0x0804000

## 代码段.text

代码段也称正文段或文本段，通常用于存放程序执行代码(即CPU执行的机器指令)

## 只读数据段.rodata

ro为read only之意，存放只读数据：字符串常量（如"hello"）和const修饰的全局变量

注意：const修饰的全局变量是存放在常量段的，但是使用const修饰的局部变量不存放在常量段，存放在栈段

为了提高空间的利用率，有些系统中.rodata段是多个进程共享的

程序加载运行时，.rodata和.text通常合并到一个段（Text Segment）中，操作系统将这个段**只读保护**起来，防止意外的改写

## 数据段.data

已初始化且初值不为0的全局变量和静态局部变量

数据段属于静态内存分配(静态存储区)，可读可写

## 数据段.bss段

.BSS(Block Started by Symbol)

未初始化、初始值为0的全局变量和静态局部变量

未定义且初值不为0的符号(该初值即common block的大小)

.data和.bss在程序加载时合并到一个段（Data Segment）中，这个段是可读可写的

运行起来会把.bss上的变量的值都初始化成0

## 堆.heap

堆用于存放进程运行时动态分配的内存段，可动态扩张或缩减

堆中内容是匿名的，不能按名字直接访问，只能通过指针间接访问

当进程调用malloc/new(C++)等函数分配内存时，新分配的内存动态添加到堆上(扩张)；当调用free/delete(C++)等函数释放内存时，被释放的内存从堆中剔除(缩减) 

## 内存映射区域

内存映射：将虚拟内存空间与磁盘上的文件关联起来，这个过程叫内存映射

该区域常被用来加载共享库（动态库）

## 栈.stack

存放局部变量

函数的返回值和参数。

临时变量，包括非静态局部变量，以及编译器自动生成的临时变量。

保存上下文：包括函数调用前后需保持不变的寄存器。

## 内核空间

内核代码段：存放内核的代码和数据，所有进程的内核代码段都映射到同样的物理内存，并在内存中持续存在

与进程有关的数据结构段：存放进程各自的PCB和页表，并映射到不同的物理内存

## 扩充：栈与堆的区别

1）管理方式：对于栈来讲，是由编译器自动管理，无需我们手工控制；对于堆来说，释放工作由程序员控制，容易产生内存泄露

2）空间大小：一般来讲在32位系统下，堆内存可以达到3G的空间（4G有1G要给内核）；而栈的最大容量是事先规定好的（例如，在VC6下面，默认的栈空间大小是1M，可修改）

3）碎片问题：对于堆来讲，频繁的new/delete势必会造成内存空间的不连续，从而造成大量的碎片，使程序效率降低；对于栈来讲，则不会存在碎片，因为栈是先进后出的结构，一个内存块要从栈中弹出，在它上面的后进的内存块肯定要先被弹出

4）生长方向：对于堆来讲，生长方向是向上的，也就是向着内存地址增加的方向；对于栈来讲，它的生长方向是向下的，是向着内存地址减小的方向增长；

5）分配方式：堆都是动态分配的；而栈有2种分配方式：静态分配和动态分配，静态分配是编译器完成的，比如局部变量的分配，动态分配由alloca函数（类似于malloc，专门在栈中申请空间的函数）进行分配，但是即使是动态分配，它也和堆是不同，栈的动态分配是由编译器进行释放，无需我们手工释放

6）分配效率：栈是机器系统提供的数据结构，计算机会在底层对栈提供支持：分配专门的寄存器存放栈的地址，压栈出栈都有专门的指令执行，这就决定了栈的效率比较高；堆则是C/C++函数库提供的，它的机制是很复杂，例如：为了分配一块内存，库函数会在堆内存中搜索**连续的足够大小**的空间，如果没有足够大的空间（可能是由于内存碎片太多），就需要操作系统重新整理内存空间，这样就有机会分到足够大的内存，然后进行返回。显然，堆的效率比栈要低得多

