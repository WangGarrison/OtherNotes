>  《Linux高性能服务器编程》第八章笔记

# 服务器模型

**C/S模型：Client/Server，客户端/服务器模型**

- 优点：适合资源相对集中的场合，实现简单
- 缺点：服务器是通信的中心，当访问量过大时，可能所有客户都将得到很慢的响应

 <img src="img/Linux%EF%BC%9A%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%A8%8B%E5%BA%8F%E6%A1%86%E6%9E%B6.img/image-20210203105408303.png" alt="image-20210203105408303" style="zoom:50%;" />

**P2P模型：Peer to Peer，点对点模型**

- 优点：每台主机既是客户端又是服务器。使每台机器在消耗资源的同时也给别人提供服务，使资源能够充分、自由地共享
- 当用户之间传输的请求过多时，网络的负载将加重；主机之间很难互相发现（实际使用的P2P模型通常带有一个专门的发现服务器）

 <img src="img/Linux%EF%BC%9A%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%A8%8B%E5%BA%8F%E6%A1%86%E6%9E%B6.img/image-20210203110234916.png" alt="image-20210203110234916" style="zoom:50%;" />

# 服务器编程框架

**服务器基本框架：**

 <img src="img/Linux%EF%BC%9A%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%A8%8B%E5%BA%8F%E6%A1%86%E6%9E%B6.img/image-20210203110431705.png" alt="image-20210203110431705" style="zoom:50%;" />

**基本模块的功能描述：**

| 模块         | 单个服务器程序             | 服务器机群                   |
| :----------- | :------------------------- | :--------------------------- |
| I/O处理单元  | 处理客户连接，读写网络数据 | 作为接入服务器、实现负载均衡 |
| 逻辑单元     | 业务进程或线程             | 逻辑服务器                   |
| 网络存储单元 | 本地数据库、文件或缓存     | 数据库服务器                 |
| 请求队列     | 各单元之间的通信方式       | 各服务器之间的永久TCP连接    |

# I/O模型

**阻塞I/O：阻塞的文件描述符，没有事件发生就阻塞**

**非阻塞I/O：非阻塞的文件描述符，不管事件是否发生都立即返回，没有事件发生返回-1**

socket在创建的时候默认是阻塞的，可以给socket系统调用的第二个参数传递`SOCK_NONBLOCK`标志，或者通过fcntl系统调用的`F_SETFL`命令，将其设置为非阻塞的

**I/O复用**

I/O复用是最常使用的I/O通知机制。应用程序通过I/O复用函数向内核注册一组事件，内核通过I/O复用函数把其中就绪的事件通知给应用程序。

Linux上常用的I/O复用函数：select、poll和epoll_wait

I/O复用系统调用本身是阻塞的，它们能提高程序效率的原因在于它们具有同时监听多个I/O事件的能力，对I/O本身的读写操作是非阻塞的

**同步I/O模型**

I/O的读写操作是在I/O事件发生之后由应用程序来完成，要求用户代码自行执行I/O操作（将数据从内核缓冲区读入用户缓冲区，或将数据从用户缓冲区写入内核缓冲区）。

同步I/O向用户通知的是I/O就绪事件

阻塞I/O、I/O复用和信号驱动I/O都是同步I/O模型

**异步I/O模型**

异步I/O的读写操作总是立即返回，而不论I/O是否是阻塞的，因为真正的读写操作已经由内核接管。

由内核来执行I/O操作（数据在内核缓冲区和用户缓冲区之间的移动是由内核在“后台”完成的）

异步I/O向用户通知的是I/O完成事件

# 两种高效的事件处理模式

服务器程序通常要处理三类事件：**I/O事件、信号、定时事件**

对于这些事件的处理有两种高效的事件处理模式：**Reactor、Proactor**

![image-20210203114329074](img/Linux%EF%BC%9A%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%A8%8B%E5%BA%8F%E6%A1%86%E6%9E%B6.img/image-20210203114329074.png)

## Reactor模式

同步I/O模型通常用于实现Reactor模式

主线程（I/O处理单元）只负责监听文件描述符上是否有事件发生，有的话就立即将该事件通知给工作线程（逻辑单元）。除此之外，主线程不做任何其他实质性的工作。读写数据，接受新的连接，以及处理客户请求均在工作线程中完成

 <img src="img/Linux%EF%BC%9A%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%A8%8B%E5%BA%8F%E6%A1%86%E6%9E%B6.img/image-20210203115345539.png" alt="image-20210203115345539" style="zoom:50%;" />

Reactor模式中没必要区分具体的“读工作线程”和“写工作线程”，统一认为是工作线程即可，因为工作线程从请求队列中取出事件后，将根据事件的类型来决定如何处理它，是可读事件就执行读操作，是可写事件就执行写操作

## Proactor模式

异步I/O模型通常用于实现Proactor模式

Proactor模式将所有I/O操作都交给主线程和内核来处理，工作线程仅仅负责业务的逻辑。因此，Proactor模式更适合上面的服务器编程框架

 <img src="img/Linux%EF%BC%9A%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%A8%8B%E5%BA%8F%E6%A1%86%E6%9E%B6.img/image-20210203120028611.png" alt="image-20210203120028611" style="zoom:50%;" />

# 两种高效的并发模式

**并发编程**：在一台处理器上“同时”处理多个任务。目的是充分利用CPU资源，以达到最高的处理性能。

**实现并发编程的两种方式**：多线程、多进程

**并发模式**：I/O处理单元和多个逻辑单元之间协调完成任务的方法。服务器主要有两种并发编程模式：

- 半同步/半异步（half-sync/half-async）模式
- 领导者/追随者（Leader/Followers）模式

## 半同步/半异步模式

- 同步：调用某个东西时，调用方得等待这个调用返回结果才能继续往后执行

- 异步：和同步相反 调用方不会理解得到结果，而是在调用发出后调用者可用继续执行后续操作，被调用者通过状体来通知调用者，或者通过回掉函数来处理这个调用

这里的同步与异步是指：

- 同步：程序完全按照代码序列的顺序执行
- 异步：程序的执行需要由系统事件来驱动。常见的系统事件：中断、信号等

 <img src="img/Linux%EF%BC%9A%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%A8%8B%E5%BA%8F%E6%A1%86%E6%9E%B6.img/image-20210203121528274.png" alt="image-20210203121528274" style="zoom:50%;" />

**同步线程：按照同步方式运行的线程**

- 优点：效率较低，实时性较差
- 缺点：逻辑简单

**异步线程：按照异步方式运行的线程**

- 优点：执行效率高，实时性强
- 缺点：编写相对复杂，难于调试和扩展。不适合与大量的并发

**半同步/半异步模式：同时使用同步线程与异步线程，各取所长**

 <img src="img/Linux%EF%BC%9A%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%A8%8B%E5%BA%8F%E6%A1%86%E6%9E%B6.img/image-20210203122927615.png" alt="image-20210203122927615" style="zoom:50%;" />

## 领导者/追随者模式

 <img src="img/Linux%EF%BC%9A%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%A8%8B%E5%BA%8F%E6%A1%86%E6%9E%B6.img/image-20210203123148486.png" alt="image-20210203123148486" style="zoom:50%;" />

# 有限状态机

前面的几种模式是服务器的I/O处理单元、请求队列和逻辑单元之间协调完成任务的各种模式

而有效状态机（finite state machine）是逻辑单元内部的一种高效编程方法

 <img src="img/Linux%EF%BC%9A%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%A8%8B%E5%BA%8F%E6%A1%86%E6%9E%B6.img/image-20210203123837749.png" alt="image-20210203123837749" style="zoom:50%;" />![image-20210203124146387](img/Linux%EF%BC%9A%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%A8%8B%E5%BA%8F%E6%A1%86%E6%9E%B6.img/image-20210203124146387.png)

 <img src="img/Linux%EF%BC%9A%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%A8%8B%E5%BA%8F%E6%A1%86%E6%9E%B6.img/image-20210203124146387.png" alt="image-20210203124146387" style="zoom:50%;" />

# 提高服务器性能的其他建议

##  池

 <img src="img/Linux%EF%BC%9A%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%A8%8B%E5%BA%8F%E6%A1%86%E6%9E%B6.img/image-20210203124442307.png" alt="image-20210203124442307" style="zoom:50%;" />

根据不同的资源类型，池可分为多种，常见的有：内存池、进程池、线程池和连接池

- 内存池：通常用于socket的接收缓存和发送缓存
- 进程池和线程池：并发编程常用的“伎俩”。在服务器启动时，提前创建固定的数量进程或者线程，将这些进程或线程阻塞在池中，等待着处理业务。当IO复用监听到文件描述符上的事件发生，则通知阻塞在池中的进程或线程来处理，进程或线程将业务处理完成之后，又继续阻塞在池中。
- 连接池：通常用于服务器或服务器机群的内部永久连接。连接池是服务器预先和数据库程序建立的一组连接的集合。当某个逻辑单元需要访问数据库时，它可以直接从连接池中取得一个实体并使用之。待完成数据库的访问之后，逻辑单元再将该连接返还给连接池

## 数据复制

 <img src="img/Linux%EF%BC%9A%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%A8%8B%E5%BA%8F%E6%A1%86%E6%9E%B6.img/image-20210203125423624.png" alt="image-20210203125423624" style="zoom:50%;" />

## 上下文切换和锁

 <img src="img/Linux%EF%BC%9A%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%A8%8B%E5%BA%8F%E6%A1%86%E6%9E%B6.img/image-20210203131528249.png" alt="image-20210203131528249" style="zoom:50%;" />

本章完