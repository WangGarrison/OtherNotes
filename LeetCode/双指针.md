## 环形链表

> 定一个链表，判断链表中是否有环。
>
> 如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。
>
> 如果链表中存在环，则返回 true 。 否则，返回 false 。
>
> 进阶：
>
> 你能用 O(1)（即，常量）内存解决此问题吗？
>

> **示例 1：**
>
>  ![img](F:%5C%E5%AD%A6%E4%B9%A0%5C%E6%9C%AC%E5%9C%B0md%E6%96%87%E4%BB%B6%5CLeetCode%5C%E5%89%91%E6%8C%87offer.assets%5Ccircularlinkedlist.png)
>
> 输入：head = [3,2,0,-4], pos = 1
> 输出：true
> 解释：链表中有一个环，其尾部连接到第二个节点。

思路：快慢指针，快指针一次走两个，慢指针走一个，能相遇就说明有环

```c
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     struct ListNode *next;
 * };
 */
bool hasCycle(struct ListNode *head) {
    struct ListNode *low = head;
    struct ListNode *fast = head;
    while(fast!=NULL && fast->next!=NULL)
    {
        low = low->next;
        fast = fast->next->next;
        if(low == fast)
        {
            return true;
        }
        
    }
    return false;
    
}
```

## 验证回文串

> 给定一个字符串，验证它是否是回文串，只考虑字母和数字字符，可以忽略字母的大小写。
>
> 说明：本题中，我们将空字符串定义为有效的回文串。
>
> 示例 1:
>
> 输入: "A man, a plan, a canal: Panama"
> 输出: true

思路：方法一：先把字符串的字母全转为小写并且去除其他字符，存储在新数组

新数组双指针一个从前一个从后，遍历比较

```c
bool isPalindrome(char * s)
{
    if(strlen(s) == 0 || strlen(s) == 1)
    {
        return true;
    }
    //先把字符串的字母全转为小写并且去除其他字符，存储在新数组
    //新数组双指针一个从前一个从后，遍历比较
    char *arr = (char *)malloc((strlen(s)+1)*sizeof(char));
    int i,j;
    for(i = 0, j=0;i<strlen(s);i++)
    {
        if(isdigit(s[i]))
        {
            arr[j] = s[i];
            j++;
        }
        else if(isalpha(s[i]))
        {
            isupper(s[i]) ? (arr[j] = tolower(s[i])) : (arr[j] = s[i]);
            j++;
        }
        else
        {
            ;
        }
    }
    arr[j] = '\0';
    for(int head = 0,tail = j-1;head<tail;head++,tail--)
    {
        if(arr[head] != arr[tail])
        {
            return false;
        }
    }
    return true;
}
```

方法二：双指针一个从前一个从后，遍历比较

```c
bool isPalindrome(char * s)
{
    if(strlen(s) == 0 || strlen(s) == 1)
    {
        return true;
    }

    //双指针一个从前一个从后，遍历比较
    for(int i = 0, j = strlen(s)-1;i<j;)
    {
        if(!isalnum(s[i]))
        {
            i++;
            continue;
        }
        if(!isalnum(s[j]))
        {
            j--;
            continue;
        }
        if(tolower(s[i]) != tolower(s[j]))
        {
            return false;
        }
        i++;
        j--;
    }
    return true;
    
}
```

## 合并两个有序数组

> 给你两个有序整数数组 nums1 和 nums2，请你将 nums2 合并到 nums1 中，使 nums1 成为一个有序数组。
>
>  说明：
>
> 初始化 nums1 和 nums2 的元素数量分别为 m 和 n 。
> 你可以假设 nums1 有足够的空间（空间大小大于或等于 m + n）来保存 nums2 中的元素。
>
>
> 示例：
>
> 输入：
> nums1 = [1,2,3,0,0,0], m = 3
> nums2 = [2,5,6],       n = 3
>
> 输出：[1,2,2,3,5,6]
>

思路：创建一个新数组，同时遍历nums1和nums2两数组，小的往下放

```c
void merge(int* nums1, int nums1Size, int m, int* nums2, int nums2Size, int n)
{
    //创建一个新数组，同时遍历nums1和nums2两数组，小的往下放
    int *rt = (int *)malloc(nums1Size*sizeof(int));
    int i = 0,j = 0;
    int index = 0;//rt数组的下标
    while(i < m && j < n)
    {
        if(nums1[i] < nums2[j])
        {
            rt[index++] = nums1[i++];
        }
        else
        {
            rt[index++] = nums2[j++];
        }
    }

    while(i<m)
    {
        rt[index++] = nums1[i++];
    }
    while(j<n)
    {
        rt[index++] = nums2[j++];
    }
    for(i = 0;i<nums1Size;i++)
    {
        nums1[i] = rt[i];
    }
    free(rt);    
}
```

## 验证回文链表

请判断一个链表是否为回文链表。

**示例 1:**

```
输入: 1->2
输出: false
```

**示例 2:**

```
输入: 1->2->2->1
输出: true
```

思路：将值复制到数组，再判断是否为回文

```c
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     struct ListNode *next;
 * };
 */

bool isPalindrome(struct ListNode* head){
    //将值复制到数组，再判断是否为回文
    if(head == NULL || head->next == NULL)
    {
        return true;
    }
    int arrSize = 0;
    struct ListNode* tmp = head;
    while(tmp!=NULL)
    {
        tmp = tmp->next;
        arrSize++;
    }
    int *arr = (int *)malloc(arrSize*sizeof(int));
    for(int i=0;i<arrSize;i++)
    {
        arr[i] = head->val;
        head = head->next;
    }
    int start = 0,end = arrSize-1;
    while(start<arrSize)
    {
        if(arr[start]!=arr[end])
        {
            return false;
        }
        start++;
        end--;
    }
    return true;
}
```

