## 搜索旋转排序树组

> 给你一个升序排列的整数数组 nums ，和一个整数 target 。
>
> 假设按照升序排序的数组在预先未知的某个点上进行了旋转。（例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] ）。
>
> 请你在数组中搜索 target ，如果数组中存在这个目标值，则返回它的索引，否则返回 -1 。
>
> 示例 1：
> 输入：nums = [4,5,6,7,0,1,2], target = 0
> 输出：4
>
> 示例 2：输入：nums = [4,5,6,7,0,1,2], target = 3
> 输出：-1
> 示例 3：输入：nums = [1], target = 0
> 输出：-1

方法一：暴力遍历

```c
int search(int* nums, int numsSize, int target)
{
    //直接遍历
    for(int i = 0; i<numsSize;i++)
    {
        if(nums[i] == target)
            return i;
    }
    return -1;
}
```

方法二：只对有序的部分二分查找，有序部分没找到切掉找过的，剩余的继续在有序部分二分查找

```c
//二分查找基本形式
int BinSearch(int *nums, int left, int right, int target)
{
    while(left <= right)
    {
        int mid = left + (right - left) / 2;
        if(nums[mid] == target )
        {
            return mid;
        }
        else if(nums[mid] < target)
        {
            left = mid+1;
        }
        else
        {
            right = mid-1;
        }
    }
    return -1;
}
int search(int* nums, int numsSize, int target)
{
    //二分查找，先搜索有序部分的
    int left = 0, right = numsSize -1;
    int rt = -1;
    while(left<=right)
    {
        int mid = left + (right - left)/2;
        if(nums[mid]>=nums[left])//左半部分有序在左办部分进行二分查找
        {
            rt  =  BinSearch(nums,left,mid,target);
            if(rt == -1)//左半部分没有找到
            {
                left = mid + 1;//切掉找过的左半部分，在剩余的里边继续找有序的部分
                continue;
            }
            else
            {
                return rt;
            }
        }
        else//右半部分有序在右办部分查找
        {
            rt = BinSearch(nums,mid,right,target);
            if(rt == -1)//右半部分没有找到
            {
                right = mid - 1;////切掉找过的右半部分，在剩余的里边继续找有序的部分
                continue;
            }
            else
            {
                return rt;
            }
        }
    }
   
    return rt;
}
```